---
layout: post
title:  "高效整型编码压缩之Variable-width-Encoding"
date:   2014-03-16
categories: 
- Notes 
tags:
- Linux
---

**Variable-width-Encoding**是基于 Google's protocol buffers ，是使用一个或多个字节表示整型数据的方法（字节是此编码的基本单元）
。其中数值本身越小，其所占用的字节数越少. 在varint中，每个字节中都包含一个msb(most significant bit)设置(使用最高位)，这意味着
其后的字节是否和当前字节一起来表示同一个整型数值。而字节中的其余七位将用于存储数据本身。如果高位是1则表示后面还有字节来表示
同一个整数值，如果高位是0则表示此字节是此数的最后一个字节。通常而言，整数数值都是由字节表示，其中每个字节为8位，即Base 256。
然而在Protocol Buffer的编码中，最高位成为了msb，只有后面的7位存储实际的数据，因此我们称其为Base 128（2的7次方）。考虑到此高
位的值的含义已经取代了符号位的含义，那么对于负数的编码，需要先使用zigzag编码把负数映射为非负数。这种编码对于小的值的存储比
较有效果。

由于Protocol Buffer是按照Little Endian的方式进行数据布局的，因此我们这里需要将两个字节的位置进行翻转
      
比如数字1，它本身只占用一个字节即可表示，所以它的msb为其本身的值，如：
 0000 0001
 
再比如十进制数字300，它的编码后表示形式为：

1010 1100 0000 0010

对于Protocol Buffer而言又是如何将上面的字节布局还原成300呢？这里我们需要做的第一步是drop掉每个字节的msb。从上例中可以看出第
一个字节（1010 1100）的msb（最高位）被设置为1，这说明后面的字节将连同该字节表示同一个数值，而第二个字节（0000 0010）的msb
为0，因此该字节将为表示该数值的最后一个字节了，后面如果还有其他的字节数据，将表示其他的数据。

1010 1100 0000 0010

-> 010 1100 000 0010

上例中的第二行已经将第一行中每一个字节的msb去除。由于Protocol Buffer是按照Little Endian的方式进行数据布局的，因此我们这里
需要将两个字节的位置进行翻转。

010 1100 000 0010

-> 000 0010 010 1100           //翻转第一行的两个字节

-> 100101100                    //将翻转后的两个字节直接连接并去除高位0

-> 256 + 32 + 8 + 4 = 300    //将上一行的二进制数据换算成十进制，其值为300.

上面的举例是反编码，下面举例如何编码为Protocol Buffer.

先表示具体值----从低位开始以7为模划分，不足的补为0----翻转数据（小端存储）-----添加msb值0 OR 1.

比如java  int  137 ，其不做编码的二进制表示为0000000  00000000  00000000 10001001 需要4个字节，有效位是 10001001，对其进行
处理：
1.	7 bit 一组，把二进制分开，不足的补 0 ，变成 0000001 0001001翻转数据，0001001  0000001

2. 把最低的7位拿出来，在最高位补0表示最后一位，变成00000001，这个作为最低位，放在最后边。

3. 在其他组的最高位补 1 ，表示没有结束，后面跟着还有数据。在这里就是 10001001

4. 拼在一起，就变成了 10001001  00000001 只需要两个字节就可以存储。 

