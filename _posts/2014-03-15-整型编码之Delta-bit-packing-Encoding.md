---
layout: post
title:  "整型编码之Delta-bit-packing-Encoding"
date:   2014-03-15
categories: 
- Notes 
tags:
- Linux
---

**Delta  bit -packing  Encoding**即增量编码和位编码混合编码。以7,5,3,1,2,3,4,5为例：先计算出两个相邻的值的增量，分别为 -2 -2 -2 1 1 1 1 ，在计算的同时保存最小的增量值，这里是-2.需要注意的是最小的增量值-2使用zigzag VLQ  int(此时-2变为3)类型来保存的。接下来
对-2 -2 -2 1 1 1 1 分别减去最小的增量值-2,则变为 0,0,0，3,3,3，3 ，最大值3的二进制代码为0000000 0000000  0000000 000000011 
有效编码是11两位，那么就使用2个bit来保存所有的增量差, 所以这里用一个byte来保存width 2.对这个序列采用位编码。即依次为00 00 00
11 11 11 11 。增量编码保存值的顺序为：first value(7  zigzag VLQ int 变为14)  minimum  delta(- 2 zigzag VLQ int 变为3)  bitwidth
(2  1byte)  bitcode(00 00 00 11 11 11 11) .所以7,5,3,1,2,3,4,5的增量编码为：00001110（14） 00000011（3） 00000010（2）  00000
011 111111 共计花费8+8+8+14=38位，比原先的32*8=256位减少很多。

在这里简要说一下ZigZag VLQ int，这种编码风格源自于google protobuffer, zigzag主要是应对针对负数的编码，该编码会将有符号整型映
射为无符号整型，以便绝对值较小的负数仍然可以有较小的varint编码值，如-1.下面是ZigZag对照表：

Signed Original --------- Encoded As

-1       ----------------1

1        ----------------2

-2	     ----------------3

2147483647	-------------4294967294

-2147483648	-------------4294967295

其公式为：

n << 1) ^ (n >> 31)    //sint32
(n << 1> ^ (n >> 63)       //sint64

需要补充说明的是，Protocol Buffer在实现上述位移操作时均采用的算术位移，因此对于(n >> 31)和(n >> 63)而言，如果n为负值位移后的结果就是-1，否则就是0。


**优缺点以及适合场景**

优点：此种编码是在值随机分布情况中综合性能最好的，它不要求你的值是连续重复或者是等差数列，也不受限于数据的有效2进制位的个数
，仅仅希望相邻数值的增量差小点就行。此编码的性能除了收到相邻数据的增量的差的大小的影响，还受到一个人为设定的基本粒度的大小的
影响，应为其采用的位编码的2进制位的个数取决于基本编码粒度中最大的增量差的有效2进制位数。

缺点：如果相邻数值的增量差波动很大，那么编码效果有限

适合场景：相邻value增量差较小


**参考文献** 

1.http://lemire.me/blog/archives/2012/09/12/fast-integer-compression-decoding-billions-of-integers-per-second/
2.http://lemire.me/blog/archives/2012/10/23/when-is-a-bitmap-faster-than-an-integer-list/
