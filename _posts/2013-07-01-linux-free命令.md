---
layout: post
title:  "linux之Free"
date:   2013-07-01 13:17:59
categories: 
- Notes 
tags:
- Linux
---


　　下面是free的运行结果，一共有4行。为了方便说明，我加上了列号。这样可以把free的输出看成一个二维数组FO(Free Output)。例如：

   FO[2][1] = 24677460
   FO[3][2] = 10321516  
   




   ** 1             2            3             4             5              6  **
   
   **1                 total         used         free           shared        buffers      cached**
   
   **2 Mem:            24677460     23276064      1401396          0       870540     12084008**
   
   **3 -/+ buffers/cache:    10321516      14355944**
   
   **4Swap:       25151484        224188      24927296**
   
　　free的输出一共有四行，第四行为交换区的信息，分别是交换的总量（total），使用量（used）和有多少空闲的交换区（free），这个比较清楚，不说太多。

　　free输出地第二行和第三行是老把我给搞混了。其实这两行都是说明内存使用情况的。第一列是总量（total），第二列是使用量（used），第三列是可用量（free）。

　　第一行的输出时从操作系统（OS）来看的。也就是说，从OS的角度来看，计算机上一共有:

   24677460KB（缺省时free的单位为KB）物理内存，即FO[2][1]；
   
   在这些物理内存中有23276064KB（即FO[2][2]）被使用了；
   
   还有1401396KB（即FO[2][3]）是可用的；
   
   
   
   成立的等式如下 FO[2][1] = FO[2][2] + FO[2][3]   FO[2][5]表示被OS buffer住的内存。  而FO[2][6]表示被OS             cache的内存。在有些时候buffer和cache这两个词经常混用。  这两个容易混淆的东西个人分析是buffer是用于存放要输出到disk（块设备）的数据的，而cache是存放从disk上读出的数据。这二者是为了提高IO性能的，并由OS管理。Linux和其他成熟的操作系统（例如windows），为了提高IOread的性能，总是要多cache一些数据，这也就是为什么FO[2][6]（cached memory）比较大。 **free输出的第二行是从一个应用程序的角度看系统内存的使用情况。**对于FO[3][2]，即-buffers/cache，表示一个应用程序认为系统被用掉多少内存；对于FO[3][3]，即+buffers/cache，表示一个应用程序认为系统还有多少内存；因为被系统cache和buffer占用的内存可以被快速回收，所以通常FO[3][3]比FO[2][3]会大很多。这里还用两个等式：
      一是FO[3][2] = FO[2][2] - FO[2][5] - FO[2][6]   二是FO[3][3] = FO[2][3] + FO[2][5] + FO[2][6]

　
